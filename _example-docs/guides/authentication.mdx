---
title: 'Authentication & Security'
summary: 'Secure your MCP server with various authentication patterns and best practices.'
sequence: 4
---

# Authentication & Security

Securing your MCP server is crucial. Deploxy is designed to keep your source code private, but you still need to control who can execute your server's tools. This guide covers the recommended authentication patterns and security best practices.

## Authentication Strategies

Because your server code runs in a secure, private environment, you can directly implement robust authentication and authorization logic.

### 1. API Key Authentication

The most common method is to require an API key for tool calls. Users will pass this key as an argument, which your server then validates.

<CodeBlock title="src/index.ts - API Key Validation" language="typescript">
```typescript
import { db } from '~/lib/database'; // Example database client

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const apiKey = request.params.arguments.apiKey as string;

  // Validate the API key against your database
  const isValid = await isValidApiKey(apiKey);
  if (!isValid) {
    throw new Error('Invalid or missing API key');
  }

  // Your tool logic here...
});

async function isValidApiKey(key: string): Promise<boolean> {
  if (!key) return false;
  // Example: Check if the key exists in your users table
  const user = await db.users.findFirst({ where: { apiKey: key } });
  return !!user;
}
```
</CodeBlock>

### 2. Injected Environment Variables & Headers

You can inject sensitive information, like a master API key or a service token, directly into your server's runtime environment. This is useful for server-to-server communication.

**`.deploxy.json`**
```json
{
  "injectedEnv": {
    "INTERNAL_API_KEY": "${process.env.MY_SECRET_KEY}"
  }
}
```

<Callout type="info" title="Header Forwarding">
Deploxy can also be configured to forward specific headers from the incoming proxy request to your serverless function, enabling patterns like JWT or Bearer token authentication.
</Callout>

## Security Best Practices

### Store Secrets Securely

Never hardcode secrets like API keys, database connection strings, or encryption keys in your source code. Use Deploxy's `injectedEnv` feature to manage them.

<CodeBlock title=".deploxy.json - Secure Environment Variables" language="json">
```json
{
  "injectedEnv": {
    "DATABASE_URL": "${process.env.PROD_DATABASE_URL}",
    "STRIPE_API_KEY": "${process.env.STRIPE_SECRET_KEY}"
  }
}
```
</CodeBlock>

### Implement Rate Limiting

Protect your service from abuse by implementing rate limiting. Since your code runs on a server, you can use databases like Redis or DynamoDB to track usage per user.

<CodeBlock title="src/rate-limiter.ts - Example Rate Limiting" language="typescript">
```typescript
import { redis } from '~/lib/redis'; // Example Redis client

const RATE_LIMIT_MAX = 100; // 100 requests
const RATE_LIMIT_WINDOW = 60 * 60; // 1 hour in seconds

export async function checkRateLimit(userId: string): Promise<void> {
  const key = `rate-limit:${userId}`;
  const current = await redis.get(key);

  if (current && parseInt(current, 10) > RATE_LIMIT_MAX) {
    throw new Error('Rate limit exceeded');
  }

  const pipeline = redis.pipeline();
  pipeline.incr(key);
  pipeline.expire(key, RATE_LIMIT_WINDOW);
  await pipeline.exec();
}
```
</CodeBlock>

### Validate and Sanitize All Inputs

Always validate the `arguments` passed to your tools to prevent injection attacks and ensure data integrity. Libraries like `zod` are excellent for this.

<CodeBlock title="src/index.ts - Input Validation with Zod" language="typescript">
```typescript
import { z } from 'zod';

const SearchToolSchema = z.object({
  query: z.string().min(1).max(200),
  limit: z.number().min(1).max(50).default(10),
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === 'search') {
    const validationResult = SearchToolSchema.safeParse(request.params.arguments);
    if (!validationResult.success) {
      throw new Error(`Invalid input: ${validationResult.error.message}`);
    }
    // Use validated and sanitized input
    const { query, limit } = validationResult.data;
    // ... process the request
  }
});
```
</CodeBlock>

## User and Credit Management

A key advantage of Deploxy is the ability to manage user accounts and billing logic directly within your MCP server.

### Implementing a Credit System

You can connect to your database to check a user's credit balance before executing a tool.

<CodeBlock title="src/billing.ts - Credit Deduction Logic" language="typescript">
```typescript
import { db } from '~/lib/database';

const TOOL_COST = 1; // 1 credit per call

export async function deductCredits(apiKey: string): Promise<void> {
  const user = await db.users.findFirst({ where: { apiKey } });

  if (!user) {
    throw new Error('User not found');
  }

  if (user.credits < TOOL_COST) {
    throw new Error('Insufficient credits');
  }

  await db.users.update({
    where: { id: user.id },
    data: { credits: user.credits - TOOL_COST },
  });
}
```
</CodeBlock>

This logic can then be integrated into your tool handler:

<CodeBlock title="src/index.ts - Integrating Billing" language="typescript">
```typescript
import { deductCredits } from './billing';

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const apiKey = request.params.arguments.apiKey as string;
  
  // This will throw an error if the user has insufficient credits
  await deductCredits(apiKey);

  // If deduction is successful, proceed with tool logic
  return await processTool(request.params);
});
```
</CodeBlock>
