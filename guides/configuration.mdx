---
title: 'Configuration'
sidebarTitle: 'Configuration'
description: 'A deep dive into the .deploxy.json file, managing environment variables, regional settings, and other advanced deployment configurations.'
sequence: 5
keywords: ['configuration', 'deploxy.json', 'environment variables', 'env', 'secrets', 'regions', 'advanced', 'environments', 'staging', 'production', 'development', 'dev', 'prod', 'injectedEnv', 'ci/cd']
icon: 'settings'
---

# Configuration

This guide covers the configuration options available in your `.deploxy.json` file, allowing you to manage environments, secrets, and fine-tune your deployments.

## The `.deploxy.json` File

This file is the heart of your Deploxy project configuration. It tells the CLI how to build, deploy, and manage your MCP server.

### Basic Structure

Here is a comprehensive example of the `.deploxy.json` file with commonly used options:

```json
{
  "authToken": "YOUR_DEPLOXY_TOKEN",
  "defaultDeployRegion": "us-east-1",
  "stdioArgsIndex": "--args",
  "packageType": "js",
  "nodejsRuntime": "nodejs22x",
  "memorySizeMB": 256,
  "injectedEnv": {
    "NODE_ENV": "production",
    "DATABASE_URL": "YOUR_DATABASE_URL",
    "STRIPE_API_KEY": "YOUR_SECRET_KEY"
  },
  "buildOptions": {
    "pkgManager": "npm",
    "preInstallCommand": "",
    "installCommand": "npm install --proudction",
    "postInstallCommand": ""
  }
}
```

### Key Properties

-   **`authToken`** (required): Your Personal Access Token from the Deploxy dashboard. It's recommended to use an environment variable for this, e.g., `"${process.env.DEPLOXY_TOKEN}"`.
-   **`defaultDeployRegion`** (required): The primary routing AWS region where your serverless function will be deployed. Choose the region closest to your users for the best performance.
-   **`stdioArgsIndex`** (optional): Specifies the command-line flag that separates your script's arguments from the arguments intended for the MCP server. Defaults to `"--args"`.
-   **`packageType`** (required): The type of your package. Currently, only `"js"` for JavaScript/TypeScript projects is supported. Python support is coming soon.
-   **`nodejsRuntime`** (optional): The NodeJS runtime for your serverless function. Defaults to `"nodejs22x"`. You can choose `"nodejs20x"` or `"nodejs22x"`
-   **`memorySizeMB`** (optional): The serverless function memory limit. Defaults to `256`. You can choose `256`, `512`, `1024`, `2048`, `4096`
-   **`injectedEnv`** (optional): A key-value map of environment variables that will be securely injected into your serverless function's runtime. This is the recommended way to handle secrets and environment-specific configuration.

## Secure Environment Management with `injectedEnv`

A key feature of Deploxy's architecture is the strict separation between your private, server-side MCP server and the lightweight proxy client that end-users install. The `injectedEnv` property is the primary tool for managing configuration securely.

<Callout type="warning" title="Server-Side Only">
These variables are **never** included in the client-side proxy package published to NPM and are **never** exposed to the end-user. They exist exclusively within the secure Deploxy cloud environment where your MCP server code executes.
</Callout>

This allows you to safely manage sensitive data like:
- Database connection strings
- Private API keys for other services (e.g., Stripe, OpenAI)
- Environment-specific settings (e.g., `development` vs. `production`)

### How It Works: Static vs. Dynamic Variables

Your `.deploxy.json` can define two types of injected variables:

1.  **Static Variables**: The value is hardcoded. Useful for non-sensitive, fixed values like a log level.
2.  **Dynamic Variables**: The value is read from the environment where you run the `npx @deploxy/cli deploy` command. This is the **required method for all secrets**.

Here’s a typical configuration using both:

```json .deploxy.json
{
  "injectedEnv": {
    "LOG_LEVEL": "info", // Static value
    "API_SECRET": "${process.env.MY_API_SECRET}" // Dynamic value from your local/CI environment
  }
}
```

<Callout type="warning" title="Security Note">
When using dynamic variables like `${process.env.VAR_NAME}`, the value is resolved by the Deploxy CLI from the environment where the `deploy` command is run. These values are then securely transmitted and stored in your function's environment, never in your repository.
</Callout>

### Value Types: Strings Only

It is crucial to remember that all environment variables, and therefore all values within the `injectedEnv` object, must be **strings**. This is a standard convention for environment variables across all platforms.

Providing non-string values like numbers, booleans, or nested objects will result in a deployment error.

<CodeBlock title=".deploxy.json - Correct ✅" language="json">
```json
{
  "injectedEnv": {
    "ENABLE_FEATURE_X": "true",
    "API_TIMEOUT_MS": "30000",
    "CONFIG_JSON": "{\"key\":\"value\",\"nested\":true}"
  }
}
```
</CodeBlock>

<CodeBlock title=".deploxy.json - Incorrect ❌" language="json">
```json
{
  "injectedEnv": {
    "ENABLE_FEATURE_X": true,
    "API_TIMEOUT_MS": 30000,
    "CONFIG_JSON": {
      "key": "value",
      "nested": true
    }
  }
}
```
</CodeBlock>

<Callout type="info" title="Handling Data Types in Your Code">
In your server-side code, you will need to parse these string values back into their intended types.

```typescript
const featureXEnabled = process.env.ENABLE_FEATURE_X === 'true';
const timeout = parseInt(process.env.API_TIMEOUT_MS, 10);
const config = JSON.parse(process.env.CONFIG_JSON);
```
</Callout>

### Practical Workflow with `.env` Files

The most effective way to manage dynamic variables for different environments is with `.env` files.

#### 1. Create Environment-Specific `.env` Files

Create separate `.env` files for each environment. **Crucially, add `.env*` to your `.gitignore` file to prevent committing secrets to version control.**

**.env.development**
```
NODE_ENV=development
DATABASE_URL=postgres://user:pass@dev-db.example.com/mydb
STRIPE_API_KEY=sk_test_...
```

**.env.production**
```
NODE_ENV=production
DATABASE_URL=postgres://user:pass@prod-db.example.com/mydb
STRIPE_API_KEY=sk_live_...
```

#### 2. Deploy Using a Specific Environment

Use a tool like `dotenv-cli` to load these variables before deploying. This keeps your deployment command clean and your configuration secure.

```bash
# Deploy using development settings
npx dotenv -e .env.development -- npx @deploxy/cli deploy

# Deploy using production settings
npx dotenv -e .env.production -- npx @deploxy/cli deploy
```

### Accessing Variables in Your Server Code

Inside your MCP server's code, these injected variables are available via `process.env`.

```typescript
// This code runs securely on the Deploxy server, not on the client.
import { connectToDatabase } from './database';
import Stripe from 'stripe';

// Initialize services with securely injected environment variables
const db = connectToDatabase(process.env.DATABASE_URL);
const stripe = new Stripe(process.env.STRIPE_API_KEY);

export async function handleToolCall(request) {
  // Your logic here can now securely access the database and Stripe
}
```

## Regional Configuration

While `defaultDeployRegion` sets the primary location, you can deploy to multiple regions for higher availability and lower latency.

### Multi-Region Deployments

To deploy to multiple regions, you can maintain separate configuration files for each environment or use the CLI's `--region` flag.

**Example using a region-specific config file (`.deploxy.us-west-2.json`):**
```json
{
  "extends": "./.deploxy.json", // Inherits from the base config
  "defaultDeployRegion": "us-west-2"
}
```

Then deploy using:
```bash
npx @deploxy/cli deploy --config .deploxy.us-west-2.json
```

### Available Regions

Deploxy deploys to a wide range of global regions. For a complete and up-to-date list of all supported regions and their identifiers, please see the [Available Regions](/resources/regions) documentation.

## Advanced Build Options (Future)

While the current version of Deploxy automatically handles most build configurations, future versions will allow for more granular control over the build process directly within `.deploxy.json`.

**Example of potential future configuration:**
```json
{
  "buildOptions": {
    "nodeVersion": "20",
    "installCommand": "pnpm install --frozen-lockfile",
    "buildCommand": "pnpm build",
    "outputDirectory": "build"
  }
}
```

For now, ensure your `package.json` `scripts` and `tsconfig.json` are correctly configured, as the CLI uses them as the source of truth for the build process.