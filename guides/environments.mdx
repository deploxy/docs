---
title: 'Secure Environment Management'
summary: 'Learn how to securely provide configuration to your private MCP server using injected environment variables.'
sequence: 5
---

# Secure Environment Management

A key feature of Deploxy's architecture is the strict separation between your private, server-side MCP server and the lightweight proxy client that end-users install. Environment management is designed around this principle, ensuring that your secrets and configuration always remain secure on the server.

The primary tool for this is the `injectedEnv` property in your `.deploxy.json` file.

## Understanding `injectedEnv`

The `injectedEnv` property defines a set of environment variables that are securely injected *only* into the runtime of your private serverless function.

<Callout type="warning" title="Server-Side Only">
These variables are **never** included in the client-side proxy package published to NPM and are **never** exposed to the end-user. They exist exclusively within the secure Deploxy cloud environment where your MCP server code executes.
</Callout>

This allows you to safely manage sensitive data like:
- Database connection strings
- Private API keys for other services (e.g., Stripe, OpenAI)
- Environment-specific settings (e.g., `development` vs. `production`)

### How It Works: Static vs. Dynamic Variables

Your `.deploxy.json` can define two types of injected variables:

1.  **Static Variables**: The value is hardcoded. Useful for non-sensitive, fixed values like a log level.
2.  **Dynamic Variables**: The value is read from the environment where you run the `npx @deploxy/cli deploy` command. This is the **required method for all secrets**.

Here’s a typical `.deploxy.json` configuration:

```json .deploxy.json
{
  "authToken": "${process.env.DEPLOXY_TOKEN}",
  "defaultDeployRegion": "ap-northeast-2",
  "mcpPath": "/mcp",
  "packageType": "js",
  "injectedEnv": {
    "NODE_ENV": "${process.env.NODE_ENV}",
    "DATABASE_URL": "${process.env.DATABASE_URL}",
    "STRIPE_API_KEY": "${process.env.STRIPE_API_KEY}"
  }
}
```

When you run `npx @deploxy/cli deploy`, the CLI resolves the values of `NODE_ENV`, `DATABASE_URL`, and `STRIPE_API_KEY` from your local shell or CI/CD environment. It then securely transmits these values to your serverless function's configuration.

### Value Types: Strings Only

It is crucial to remember that all environment variables, and therefore all values within the `injectedEnv` object, must be **strings**. This is a standard convention for environment variables across all platforms.

Providing non-string values like numbers, booleans, or nested objects will result in a deployment error.

<CodeBlock title=".deploxy.json - Correct ✅" language="json">
```json
{
  "injectedEnv": {
    "ENABLE_FEATURE_X": "true",
    "API_TIMEOUT_MS": "30000",
    "CONFIG_JSON": "{\"key\":\"value\",\"nested\":true}"
  }
}
```
</CodeBlock>

<CodeBlock title=".deploxy.json - Incorrect ❌" language="json">
```json
{
  "injectedEnv": {
    "ENABLE_FEATURE_X": true,
    "API_TIMEOUT_MS": 30000,
    "CONFIG_JSON": {
      "key": "value",
      "nested": true
    }
  }
}
```
</CodeBlock>

<Callout type="info" title="Handling Data Types in Your Code">
In your server-side code, you will need to parse these string values back into their intended types.

```typescript
const featureXEnabled = process.env.ENABLE_FEATURE_X === 'true';
const timeout = parseInt(process.env.API_TIMEOUT_MS, 10);
const config = JSON.parse(process.env.CONFIG_JSON);
```
</Callout>

## Practical Workflow with `.env` Files

The most effective way to manage dynamic variables for different environments is with `.env` files.

### 1. Create Environment-Specific `.env` Files

Create separate `.env` files for each environment. **Crucially, add `.env*` to your `.gitignore` file to prevent committing secrets to version control.**

**.env.development**
```
NODE_ENV=development
DATABASE_URL=postgres://user:pass@dev-db.example.com/mydb
STRIPE_API_KEY=sk_test_...
```

**.env.production**
```
NODE_ENV=production
DATABASE_URL=postgres://user:pass@prod-db.example.com/mydb
STRIPE_API_KEY=sk_live_...
```

### 2. Deploy Using a Specific Environment

Use a tool like `dotenv-cli` to load these variables before deploying. This keeps your deployment command clean and your configuration secure.

```bash
# Deploy using development settings
npx dotenv -e .env.development -- npx @deploxy/cli deploy

# Deploy using production settings
npx dotenv -e .env.production -- npx @deploxy/cli deploy
```

## Accessing Variables in Your Server Code

Inside your MCP server's code, these injected variables are available via `process.env`.

```typescript
// This code runs securely on the Deploxy server, not on the client.
import { connectToDatabase } from './database';
import Stripe from 'stripe';

// Initialize services with securely injected environment variables
const db = connectToDatabase(process.env.DATABASE_URL);
const stripe = new Stripe(process.env.STRIPE_API_KEY);

export async function handleToolCall(request) {
  // Your logic here can now securely access the database and Stripe
}
```

This powerful pattern allows you to build robust, secure applications, confident that your sensitive configuration is handled correctly and never exposed.
