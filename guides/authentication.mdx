---
title: 'Authentication and Security'
description: 'Secure your MCP server with API keys, environment variables, and other best practices for authentication and authorization.'
sequence: 4
keywords: ['authentication', 'security', 'api key', 'auth', 'authorization', 'rate limit', 'billing', 'credits']
icon : 'lock-keyhole'
---

# Authentication & Security

Securing your MCP server is crucial. Deploxy is designed to keep your source code private, but you still need to control who can execute your server's tools. This guide covers the recommended authentication patterns and security best practices.

## Authentication Strategies

Because your server code runs in a secure, private environment, you can directly implement robust authentication and authorization logic.

### 1. API Key Authentication

The most common method is to require an API key for tool calls. Users will pass this key as an argument, which your server then validates.

<CodeBlock title="src/index.ts - API Key Validation" language="typescript">
```typescript
import { db } from '~/lib/database'; // Example database client

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const apiKey = request.params.arguments.apiKey as string;

  // Validate the API key against your database
  const isValid = await isValidApiKey(apiKey);
  if (!isValid) {
    throw new Error('Invalid or missing API key');
  }

  // Your tool logic here...
});

async function isValidApiKey(key: string): Promise<boolean> {
  if (!key) return false;
  // Example: Check if the key exists in your users table
  const user = await db.users.findFirst({ where: { apiKey: key } });
  return !!user;
}
```
</CodeBlock>

### 2. Injected Environment Variables & Headers

You can inject sensitive information, like a master API key or a service token, directly into your server's runtime environment. This is useful for server-to-server communication.

**`.deploxy.json`**
```json
{
  "injectedEnv": {
    "INTERNAL_API_KEY": "${process.env.MY_SECRET_KEY}"
  }
}
```

<Callout type="info" title="Header Forwarding">
Deploxy can also be configured to forward specific headers from the incoming proxy request to your serverless function, enabling patterns like JWT or Bearer token authentication.
</Callout>

## Security Best Practices

### Store Secrets Securely

Never hardcode secrets like API keys, database connection strings, or encryption keys in your source code. Use Deploxy's `injectedEnv` feature to manage them.

<CodeBlock title=".deploxy.json - Secure Environment Variables" language="json">
```json
{
  "injectedEnv": {
    "DATABASE_URL": "${process.env.PROD_DATABASE_URL}",
    "STRIPE_API_KEY": "${process.env.STRIPE_SECRET_KEY}"
  }
}
```
</CodeBlock>

### Implement Rate Limiting

Protect your service from abuse by implementing rate limiting. Since your code runs on a server, you can use databases like Redis or DynamoDB to track usage per user.

<CodeBlock title="src/rate-limiter.ts - Example Rate Limiting" language="typescript">
```typescript
import { redis } from '~/lib/redis'; // Example Redis client

const RATE_LIMIT_MAX = 100; // 100 requests
const RATE_LIMIT_WINDOW = 60 * 60; // 1 hour in seconds

export async function checkRateLimit(userId: string): Promise<void> {
  const key = `rate-limit:${userId}`;
  const current = await redis.get(key);

  if (current && parseInt(current, 10) > RATE_LIMIT_MAX) {
    throw new Error('Rate limit exceeded');
  }

  const pipeline = redis.pipeline();
  pipeline.incr(key);
  pipeline.expire(key, RATE_LIMIT_WINDOW);
  await pipeline.exec();
}
```
</CodeBlock>

### Validate and Sanitize All Inputs

Always validate the `arguments` passed to your tools to prevent injection attacks and ensure data integrity. Libraries like `zod` are excellent for this.

<CodeBlock title="src/index.ts - Input Validation with Zod" language="typescript">
```typescript
import { z } from 'zod';

const SearchToolSchema = z.object({
  query: z.string().min(1).max(200),
  limit: z.number().min(1).max(50).default(10),
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === 'search') {
    const validationResult = SearchToolSchema.safeParse(request.params.arguments);
    if (!validationResult.success) {
      throw new Error(`Invalid input: ${validationResult.error.message}`);
    }
    // Use validated and sanitized input
    const { query, limit } = validationResult.data;
    // ... process the request
  }
});
```
</CodeBlock>

### Handling Errors Gracefully

When an error occurs in your server (like an invalid API key, failed database connection, or insufficient credits), it's crucial to communicate it back to the client in a structured way. Simply throwing a generic `Error` is not enough.

The MCP SDK expects errors to be returned in a specific JSON format. You should catch any potential errors and re-format them accordingly.

<CodeBlock title="src/index.ts - Proper Error Handling" language="typescript">
```typescript
import { MCPError, MCPErrorType } from '@deploxy/mcp-server'; // Assuming MCPError is available

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const apiKey = request.params.arguments.apiKey as string;

    // 1. Validate API Key
    const isValid = await isValidApiKey(apiKey);
    if (!isValid) {
      // Throw a structured error
      throw new MCPError(MCPErrorType.PERMISSION_DENIED, 'Invalid or missing API key.');
    }

    // 2. Deduct Credits
    await deductCredits(apiKey); // This function might also throw an MCPError

    // 3. Process the actual tool logic
    return await processTool(request.params);

  } catch (error) {
    // If the error is already in the correct format, re-throw it
    if (error instanceof MCPError) {
      return error.toJSON();
    }

    // For unexpected errors, wrap them in a generic server error
    console.error('Unexpected server error:', error);
    return new MCPError(MCPErrorType.INTERNAL_SERVER_ERROR, 'An unexpected error occurred.').toJSON();
  }
});
```
</CodeBlock>

<Callout type="info" title="MCPError Types">
The `MCPErrorType` enum provides standard error codes (e.g., `PERMISSION_DENIED`, `INVALID_ARGUMENT`, `RESOURCE_EXHAUSTED`, `INTERNAL_SERVER_ERROR`) that client applications can use to handle different error cases programmatically.
</Callout>

## User and Credit Management

A key advantage of Deploxy is the ability to manage user accounts and billing logic directly within your MCP server.

### Implementing a Credit System

You can connect to your database to check a user's credit balance before executing a tool.

<CodeBlock title="src/billing.ts - Credit Deduction Logic" language="typescript">
```typescript
import { db } from '~/lib/database';

const TOOL_COST = 1; // 1 credit per call

export async function deductCredits(apiKey: string): Promise<void> {
  const user = await db.users.findFirst({ where: { apiKey } });

  if (!user) {
    throw new Error('User not found');
  }

  if (user.credits < TOOL_COST) {
    throw new Error('Insufficient credits');
  }

  await db.users.update({
    where: { id: user.id },
    data: { credits: user.credits - TOOL_COST },
  });
}
```
</CodeBlock>

This logic can then be integrated into your tool handler:

<CodeBlock title="src/index.ts - Integrating Billing" language="typescript">
```typescript
import { deductCredits } from './billing';

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const apiKey = request.params.arguments.apiKey as string;
  
  // This will throw an error if the user has insufficient credits
  await deductCredits(apiKey);

  // If deduction is successful, proceed with tool logic
  return await processTool(request.params);
});
```
</CodeBlock>
