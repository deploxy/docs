---
title: 'Monitoring and Logging'
description: 'Learn how to monitor your deployments, access runtime and build logs, and implement health checks for your MCP server.'
sequence: 6
keywords: ['monitoring', 'logging', 'logs', 'metrics', 'health check', 'debugging', 'dashboard']
icon: 'search'
---

# Monitoring & Logging

Effective monitoring and logging are essential for maintaining a healthy service. Deploxy provides tools to observe your MCP server's behavior, diagnose issues, and understand its performance.

## Accessing Deployment Logs

Deploxy automatically captures the output from your serverless functions and makes it available through the dashboard and the CLI.

### Using the Deploxy Dashboard

The easiest way to view logs is through the Deploxy web interface:

1.  Navigate to your project's dashboard.
2.  Select the specific deployment you want to inspect.
3.  Click on the **"Logs"** tab.

The dashboard provides a real-time log stream with features for filtering by log level and searching for specific terms.

## Structured Logging

For the best logging experience, we recommend using structured JSON logging in your MCP server. This allows Deploxy to parse your logs correctly and provide rich filtering capabilities.

<CodeBlock title="src/index.ts - Structured Logging Example" language="typescript">
```typescript
// A simple structured logger example
function log(level, message, context = {}) {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    level: level,
    message: message,
    ...context
  }));
}

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const toolName = request.params.name;
  const requestId = request.id; // Assuming request has an ID

  log('info', 'Tool call received', { toolName, requestId });

  try {
    const result = await processTool(request.params);
    log('info', 'Tool call successful', { toolName, requestId });
    return result;
  } catch (error) {
    log('error', 'Tool call failed', { 
      toolName, 
      requestId, 
      errorMessage: error.message 
    });
    throw error;
  }
});
```
</CodeBlock>

Deploxy's log viewer will automatically parse and display fields like `level`, `toolName`, and `requestId` from your JSON logs.

## Build Logs vs. Runtime Logs

Deploxy separates logs into two categories:

1.  **Build Logs**: Output generated during the deployment process (`npm install`, `tsc`, etc.). These are useful for debugging deployment failures. You can find these on the specific deployment's details page.
2.  **Runtime Logs**: Output from your serverless function as it handles requests. These are the logs you'll see in the main "Logs" tab and access via the `deploxy logs` command.

## Monitoring Metrics

The Deploxy dashboard provides key metrics for your deployments, including:

-   **Invocation Count**: How many times your serverless function has been executed.
-   **Error Rate**: The percentage of invocations that resulted in an error.
-   **Average Duration**: The average execution time for your function.

These metrics help you understand your application's performance and identify potential bottlenecks or an increase in errors.

<Callout type="info" title="Future: Advanced Metrics">
We are working on providing more advanced metrics, including CPU and memory usage, as well as custom metrics that you can emit from your application code.
</Callout>

## Health Checks

While Deploxy monitors the health of the underlying serverless infrastructure, it's a good practice to implement a health check endpoint within your MCP server.

<CodeBlock title="src/index.ts - Health Check Tool" language="typescript">
```typescript
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    // ... your other tools
    {
      name: 'health-check',
      description: 'Performs a health check of the server',
      inputSchema: { type: 'object' },
    },
  ],
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === 'health-check') {
    // Optional: Check database connection or other dependencies
    // await db.healthCheck(); 
    return { 
      content: [{ 
        type: 'text', 
        text: JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() }) 
      }] 
    };
  }
  // ... handle other tools
});
```
</CodeBlock>

You can then set up an external monitoring service to periodically call this `health-check` tool to ensure your application logic and its dependencies are functioning correctly.
